import React, { useEffect, useMemo, useRef, useState, useCallback } from "react";
import { useLocation } from "@/contexts/LocationContext";
import mapboxgl, { Map, LngLatLike, GeoJSONSource } from "mapbox-gl";
import "mapbox-gl/dist/mapbox-gl.css";
import { Card } from "@/components/ui/card";
import { supabase } from "@/integrations/supabase/client";
import { useToast } from "@/hooks/use-toast";
import { Loader2 } from "lucide-react";

// Mapbox token from environment variables
const MAPBOX_TOKEN = import.meta.env.VITE_MAPBOX_TOKEN || "";

type MoodColor = "red" | "green" | "blue" | "yellow" | "purple" | "pink" | "indigo" | "emerald" | "amber" | "rose" | string;

interface Mood {
  id: string;
  mood_emoji: string;
  mood_color: MoodColor;
  mood_name: string;
  latitude: number;
  longitude: number;
  note?: string | null;
  created_at: string;
  user_id?: string;
  user_metadata?: {
    email?: string;
    full_name?: string;
    avatar_url?: string;
  };
  updated_at?: string;
}

interface WorldMoodMapProps {
  refreshTrigger?: number;
  onMoodSelect?: (mood: Mood) => void;
}

// Utils
const COLOR_HEX: Record<string, string> = {
  red: "#ef4444",
  green: "#22c55e",
  blue: "#3b82f6",
  yellow: "#eab308",
  purple: "#a855f7",
  pink: "#ec4899",
  indigo: "#6366f1",
  emerald: "#10b981",
  amber: "#f59e0b",
  rose: "#f43f5e",
  default: "#6b7280",
};

const clamp = (v: number, min: number, max: number) => Math.max(min, Math.min(max, v));
const normalizeLng = (lng: number) => ((lng % 360) + 540) % 360 - 180;

const isValidCoordinate = (lat: unknown, lng: unknown) => {
  const nlat = Number(lat);
  const nlng = Number(lng);
  if (Number.isNaN(nlat) || Number.isNaN(nlng)) return null;
  const clampedLat = clamp(nlat, -85, 85);
  const normLng = normalizeLng(nlng);
  if (clampedLat < -85 || clampedLat > 85 || normLng < -180 || normLng > 180) return null;
  return { lat: clampedLat, lng: normLng };
};

const getColor = (c: string) => COLOR_HEX[c] ?? COLOR_HEX.default;

const timeAgo = (iso: string) => {
  const d = new Date(iso);
  const now = new Date();
  const sec = Math.floor((now.getTime() - d.getTime()) / 1000);
  const units: [number, string][] = [
    [31536000, "year"], [2592000, "month"], [86400, "day"],
    [3600, "hour"], [60, "minute"],
  ];
  for (const [s, label] of units) {
    const i = Math.floor(sec / s);
    if (i >= 1) return `${i} ${label}${i === 1 ? "" : "s"} ago`;
  }
  return "just now";
};

// Error Boundary
class ErrorBoundary extends React.Component<{ children: React.ReactNode }, { hasError: boolean; error?: Error }> {
  state = { hasError: false, error: undefined };

  static getDerivedStateFromError(error: Error) {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error("Map error:", error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="w-full h-full flex items-center justify-center bg-red-50">
          <div className="text-center p-4">
            <h3 className="text-lg font-medium text-red-800">Map Error</h3>
            <p className="text-sm text-red-600">Failed to load the map. Please refresh the page.</p>
          </div>
        </div>
      );
    }
    return this.props.children;
  }
}

// Main Component
export const WorldMoodMap: React.FC<WorldMoodMapProps> = ({ refreshTrigger, onMoodSelect }) => {
  const mapRef = useRef<Map | null>(null);
  const mapContainerRef = useRef<HTMLDivElement>(null);
  const geolocateRef = useRef<mapboxgl.GeolocateControl | null>(null);

  const [moods, setMoods] = useState<Mood[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [userPosition, setUserPosition] = useState<[number, number] | null>(null);
  const [mapReady, setMapReady] = useState(false);
  const [locationAccuracy, setLocationAccuracy] = useState<number | null>(null);
  const { toast } = useToast();

  // Load moods from Supabase
  const loadMoods = useCallback(async () => {
    try {
      setIsLoading(true);
      const last48Hours = new Date(Date.now() - 48 * 60 * 60 * 1000).toISOString();
      const { data, error } = await supabase
        .from("moods")
        .select("*")
        .gte("created_at", last48Hours)
        .order("created_at", { ascending: false })
        .limit(2000);

      if (error) throw error;

      const clean = (data || []).flatMap((m: Mood) => {
        const coord = isValidCoordinate(m.latitude, m.longitude);
        if (!coord) return [];
        return [{ ...m, latitude: coord.lat, longitude: coord.lng }];
      });

      setMoods(clean);
    } catch (e) {
      console.error("Error loading moods:", e);
      toast({ title: "Error", description: "Failed to load mood data", variant: "destructive" });
    } finally {
      setIsLoading(false);
    }
  }, [toast]);

  // Use location context for user position
  const { location, requestLocation, error: locationError } = useLocation();

  // Request location on mount
  useEffect(() => {
    if (!location.latitude || !location.longitude) {
      requestLocation().catch(console.error);
    }
  }, []);

  // Update user position when location changes
  useEffect(() => {
    if (location.latitude && location.longitude) {
      const safe = isValidCoordinate(location.latitude, location.longitude);
      if (safe) {
        const newPosition: [number, number] = [safe.lng, safe.lat];
        setUserPosition(newPosition);
        setLocationAccuracy(location.accuracy || null);

        if (mapRef.current) {
          const currentCenter = mapRef.current.getCenter();
          const distance = Math.sqrt(
            Math.pow(currentCenter.lng - safe.lng, 2) + 
            Math.pow(currentCenter.lat - safe.lat, 2)
          ) * 100; // Rough km approximation
          
          const zoom = mapRef.current.getZoom();
          
          if (distance > 100 || zoom < 5) {
            mapRef.current.easeTo({
              center: newPosition,
              zoom: Math.max(zoom, 5),
              duration: 1000,
              essential: true
            });
          }
        }
      }
    }
  }, [location]);

  // Handle location errors
  useEffect(() => {
    if (locationError) {
      toast({
        title: "Location Error",
        description: locationError,
        variant: "destructive",
        duration: 5000
      });
    }
  }, [locationError, toast]);

  // Initialize map
  useEffect(() => {
    if (!mapContainerRef.current || !MAPBOX_TOKEN || mapRef.current) return;

    mapboxgl.accessToken = MAPBOX_TOKEN;

    const map = new mapboxgl.Map({
      container: mapContainerRef.current,
      style: "mapbox://styles/mapbox/dark-v11",
      center: [0, 20],
      zoom: 1.8,
      pitchWithRotate: false,
      dragRotate: false,
      attributionControl: false,
    });

    mapRef.current = map;

    // Add map controls
    map.addControl(new mapboxgl.AttributionControl({ compact: true }));
    map.addControl(
      new mapboxgl.NavigationControl({ 
        showCompass: false, 
        showZoom: true, 
        visualizePitch: false 
      }), 
      "top-right"
    );

    // Add geolocation control
    const geolocate = new mapboxgl.GeolocateControl({
      positionOptions: { 
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 0
      },
      trackUserLocation: true,
      showUserHeading: true,
      showAccuracyCircle: true,
      fitBoundsOptions: { 
        maxZoom: 14,
        padding: 100
      },
      showUserLocation: true
    });
    
    geolocateRef.current = geolocate;
    map.addControl(geolocate, "top-right");

    // Handle map errors
    map.on("error", (e) => {
      console.error("Map error:", e.error);
      toast({ 
        title: "Map Error", 
        description: "Failed to load the map. Please check your internet connection.", 
        variant: "destructive" 
      });
    });

    map.on("load", () => {
      setMapReady(true);
      loadMoods();
    });

    // Cleanup
    return () => {
      if (mapRef.current) {
        mapRef.current.remove();
        mapRef.current = null;
      }
    };
  }, [loadMoods, toast]);

  // Render loading state if no Mapbox token
  if (!MAPBOX_TOKEN) {
    return (
      <div className="w-full h-full bg-muted/50 flex items-center justify-center p-6">
        <div className="bg-background p-6 rounded-lg shadow-lg max-w-md text-center">
          <h3 className="text-lg font-semibold mb-2">Mapbox Token Required</h3>
          <p className="text-sm text-muted-foreground">
            Please set the{' '}
            <code className="font-mono bg-muted px-1.5 py-0.5 rounded text-foreground">
              VITE_MAPBOX_TOKEN
            </code>{' '}
            environment variable to display the map.
          </p>
        </div>
      </div>
    );
  }

  return (
    <ErrorBoundary>
      <div className="w-full h-full relative">
        <div ref={mapContainerRef} className="w-full h-full" />
        
        {/* Loading overlay */}
        {isLoading && (
          <div className="absolute inset-0 bg-black/50 flex items-center justify-center z-10">
            <Loader2 className="h-8 w-8 animate-spin text-white" />
          </div>
        )}
        
        {/* Location accuracy indicator */}
        {locationAccuracy !== null && (
          <div className="absolute bottom-4 left-4 bg-black/70 text-white text-xs px-3 py-1.5 rounded-full z-10 backdrop-blur-sm">
            Accuracy: ~{Math.round(locationAccuracy)}m
          </div>
        )}
        
        {/* Center on location button */}
        {userPosition && (
          <button
            onClick={() => {
              if (mapRef.current) {
                mapRef.current.flyTo({
                  center: userPosition,
                  zoom: Math.max(mapRef.current.getZoom(), 10),
                  speed: 1.2,
                  curve: 1.42,
                  essential: true
                });
              }
            }}
            className="absolute bottom-4 right-4 bg-white p-2 rounded-full shadow-lg z-10 hover:bg-gray-100 transition-colors"
            aria-label="Center on my location"
          >
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M12 8C9.79 8 8 9.79 8 12C8 14.21 9.79 16 12 16C14.21 16 16 14.21 16 12C16 9.79 14.21 8 12 8ZM20.94 11C20.48 6.83 17.17 3.52 13 3.06V1H11V3.06C6.83 3.52 3.52 6.83 3.06 11H1V13H3.06C3.52 17.17 6.83 20.48 11 20.94V23H13V20.94C17.17 20.48 20.48 17.17 20.94 13H23V11H20.94ZM12 19C8.13 19 5 15.87 5 12C5 8.13 8.13 5 12 5C15.87 5 19 8.13 19 12C19 15.87 15.87 19 12 19Z" fill="currentColor"/>
            </svg>
          </button>
        )}
      </div>
    </ErrorBoundary>
  );
};

export default WorldMoodMap;
